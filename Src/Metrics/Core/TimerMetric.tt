<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension="generated.cs" #>
<#@ include file="..\GenericTypes.tt" #>
using System;
using System.Diagnostics.CodeAnalysis;

namespace Metrics.Core
{
    public sealed partial class TimerMetric
    {
<#
for (var typeCount = 2; typeCount <= GenericTypeMax; typeCount++)
{
    var prevTypeList = GetGenericList(typeCount-1, GenericTypeFormat);
    var typeList = GetGenericList(typeCount, GenericTypeFormat);
    var argList = GetGenericList(typeCount, GenericArgumentFormat);
    var paramList = GetGenericList(typeCount, GenericParameterFormat);
#>
        /// <summary>
        /// Runs the <paramref name="action"/> and records the time it took.
        /// </summary>
<# for (var typeIndex = 1; typeIndex <= typeCount; typeIndex++) { #>
        /// <typeparam name="T<#= typeIndex #>">The type of the <#= ConvertToOrdinal(typeIndex) #> parameter to the <paramref name="action"/> delegate.</typeparam>
<# } #>
        /// <param name="action">Action to run and record time for.</param>
<# for (var typeIndex = 1; typeIndex <= typeCount; typeIndex++) { #>
        /// <param name="arg<#= typeIndex #>">The <#= ConvertToOrdinal(typeIndex) #> parameter of the <paramref name="action"/> delegate.</param>
<# } #>
        /// <param name="userValue">A custom user value that will be associated to the results.
        /// Useful for tracking (for example) for which id the max or min value was recorded.
        /// </param>
        /// <typeparam name="TResult">The type of the return value of the method that the <paramref name="action"/> delegate encapsulates.</typeparam>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1501:AvoidExcessiveInheritance"), SuppressMessage("Microsoft.StyleCop.CSharp.MaintainabilityRules", "SA1402:FileMayOnlyContainASingleClass", Justification = "The classes are related by implementing multiple generic signatures.")]
        public TResult Time<<#= typeList #>, TResult>(Func<<#= typeList #>, TResult> action, <#= argList #>, string userValue = null)
        {
            var start = this.clock.Nanoseconds;
            try
            {
                counter.Increment();
                return action(<#= paramList #>);
            }
            finally
            {
                counter.Decrement();
                Record(this.clock.Nanoseconds - start, TimeUnit.Nanoseconds, userValue);
            }
        }

<# } #>
<#
for (var typeCount = 2; typeCount <= GenericTypeMax; typeCount++)
{
    var prevTypeList = GetGenericList(typeCount-1, GenericTypeFormat);
    var typeList = GetGenericList(typeCount, GenericTypeFormat);
    var argList = GetGenericList(typeCount, GenericArgumentFormat);
    var paramList = GetGenericList(typeCount, GenericParameterFormat);
#>
        /// <summary>
        /// Runs the <paramref name="action"/> and records the time it took.
        /// </summary>
<# for (var typeIndex = 1; typeIndex <= typeCount; typeIndex++) { #>
        /// <typeparam name="T<#= typeIndex #>">The type of the <#= ConvertToOrdinal(typeIndex) #> parameter to the <paramref name="action"/> delegate.</typeparam>
<# } #>
        /// <param name="action">Action to run and record time for.</param>
<# for (var typeIndex = 1; typeIndex <= typeCount; typeIndex++) { #>
        /// <param name="arg<#= typeIndex #>">The <#= ConvertToOrdinal(typeIndex) #> parameter of the <paramref name="action"/> delegate.</param>
<# } #>
        /// <param name="userValue">A custom user value that will be associated to the results.
        /// Useful for tracking (for example) for which id the max or min value was recorded.
        /// </param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1501:AvoidExcessiveInheritance"), SuppressMessage("Microsoft.StyleCop.CSharp.MaintainabilityRules", "SA1402:FileMayOnlyContainASingleClass", Justification = "The classes are related by implementing multiple generic signatures.")]
        public void Time<<#= typeList #>>(Action<<#= typeList #>> action, <#= argList #>, string userValue = null)
        {
            var start = this.clock.Nanoseconds;
            try
            {
                counter.Increment();
                action(<#= paramList #>);
            }
            finally
            {
                counter.Decrement();
                Record(this.clock.Nanoseconds - start, TimeUnit.Nanoseconds, userValue);
            }
        }

<# } #>
    }
}
